Привет дружище!  
Небольшой гайд по git лично для тебя.  
Git очень большая  тема - книга по git с официального сайта, больше  
четырехста страниц. Хорошая новость в том, что для начала работы, нам  
понадобится с десяток команд. А все остальное можно подхватить по дороге.  
И так начнем

#Git#

##Install##
Для работы на Windows, идем на страницу [загрузки на оффициальном сайе](https://git-scm.com/download/win "https://git-scm.com/download/win"),   
выбираем нужную нам версию в разделе **Standalone Installer**.  

Запускаем установочный файл. Во время установки, git предложит выбрать  
текстовый редактор который будет иногда использоваться в работе  
и если ты не работаешь в Vim (дефолтный), то выбери другой - например nano.  

##Инициализация локального репозитория##
Чтобы git начал отслеживать изменеия нашего проекта, нужно инициализировать  
локальный репозиторий где git и будет ханить историю изменений.  
и указать имя пользователя и email которые будут использоваться   
в истории коммитов.

1. ПКМ по рабочему столу и в контекстном меню жмем *Open GitBash here*;  
2. Перходим в рабочую дирректорию нашего пректа изменения которого мы   
будем отслеживать;  
   __Дальше работаем только из нашего рабочега каталога в который  
   мы перешли__
3. выполняем команду _git init_  
   git создаст свою рабочую дирректирю в нашем каталоге и напишет  

   Initialized empty Git repository in C:/Users/%userName%/git/  
   %workFolder%/.git/

   также, можем убедиться в том, что _init_ сработал выполнив ls -a  
   в нашей рабочей дирректори должен быть скрытый каталог .git  
4. настрим имя пользователя и почту:
```bash
git config --global user.name "Ivan Ivanov"
git config --global user.email "somemail@email.com"
```
   всего есть три варианта параметров user
* **_--system_** - для всех пользователей;
* **_--global_** - для текущего пользователя (для всех его репозиториев);
* **_--local_** - для данного репозитория, используется как default  
и может быть упущен, например:  
```bash
git config user.name "Petr Petrov"
git config user.email "othermain@email.com"
```
Нужно помнить что --local-параметры перекрывают --global,  
a последние в свою очередь перекрывают --system  

5. Проверим сделанные нами изменения в настройках  
```bash
git config --list --global
```
Что-бы посмотреть локальные параметры user. нужно использовать флаг --local,  
а для системных параметров --system. Логика понятна.

6. Если ты не уверен, что при установке git на компьютер, в качестве редактора по умолчанию,  
ты выбрал nano, то давай настроим текстовый редактор который git будет запускать, например, когда нужно будет  
написать комментарий к коммиту.  
```bash
git config --global core.editor nano
```
Проверим, что наши настройки сохранены - для этого посмотрим файл конфигурации уровня global  
который лежит по адресу ~/
```bash
cat ~/.gitconfig
```
Там должны быть такие строчки:
```bash
[core]
        editor = nano
```
То есть в блоке _core_ параметр editor установлен на nano.

Настройки репозитория выполнены и мы можем потренироваться - будем создавать  
файлы, индексировать их в git, добавлять их на коммит-кандидаты, делать коммиты
то есть добавлять их в древо отслеживания состояния файлов и дирректорий проекта.  
Так же посмотрим историю изменений проекта и будем проверять состояние нашего репозитория.  

Поехали!

1. Во первых посмотрим состояние нашего репозитория, когда он еще пуст  
```bash
git status
```
в ответ на это git выведет сообщение: 
```bash
$ git status
On branch master

No commits yet

nothing to commit (create/copy files and use "git add" to track)
```

2. Cоздадим файл test.txt нашей рабочей дирректрии  
```bash
git status
```

3. проверим git status

```bash
$ git status
On branch master

No commits yet

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        test.txt

nothing added to commit but untracked files present (use "git add" to track)
```
И гит сообщает, что коммитов еще нет, но есть **Untracked files**. Гит видит,  
что test.txt есть но ничего не знает о нем, о его содержимом, и не сохранияет  
историю его изменений. 

4. Индексируем файл 
```bash
git add test.txt
```

Когда данная команда выполняется впервые, git индексирует файл и добавляет его на коммит-кондидат  
, а когда данная команда применяется повторно - к уже проиндексированному однажды файлу,  
то файл добавляется на коммит-кандидат.  
То есть _git add_ мы явно указываем какие из файлов проекта войдут в тот или иной коммит.  
В _git add_ мы можем передавать через пробел более одного файла. Так же, если мы хотим проиндексировать  
или добавить на коммит-кандидат все файлы из текущей нашей дирректории, то должны передать вместо имени  
файла, ссылку на текущую дирректорию, то есть "."
```bash
git add .
``` 
Если мы хоти сделать тоже самое, но со всеми файлами нашего проекта (во всех дирректориях корня нашего проекта  
то импользуем флаг --all или -A  
```bash
git add -A
```
5. Выполним git status
```bash
$ git status
On branch master

No commits yet

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)
        new file:   test.txt
```
В конце вывода, видим строку _new file:   test.txt_, то есть git и проиндексировал наш файл, и обозначил  
его статус как вновьсозданный. Далее git будет отслеживать состояние данного файла по мере того как мы будем  
добавлять его на коммит-кндидаты (_git add test.txt_) и делать коммиты с ним (_git commit_).  

6. Попробуем посмотреть историю коммитов (спойлер: она пустая)  
```bash
$ git log
fatal: your current branch 'master' does not have any commits yet
```
7. Делаем коммит. Для эого есть два простых способа: _git commit_ и _git commit -m"%uour comment%"
Даваой свой первый коммит выполним коммит без флага -m:
```bash
git commit
```
И так открылось окно текстового редактора где мы напишем комментарий...  
Основные правила написания комментария следующие:  

* Первая строка комментария будет отображаться как название коммита. Требования к ней  
Длинна - менее 50 символов.  
Не должна содержать точку в конце.  

* Остальной комментарий (на gitHub будет показан при нажатии на имя(заголовок - первую  
строку комментария) коммита - идет после **одной пустрой строки** - это обязательно,  
иначе заголовок не бует распознан системой, если не будет отделен от остального текста    
комментария  

можем написать такой комментрий  
```bash
My first coommit

* Create file test.txt
* test.txt is empty	
```
Сохраним данный изменения нажав _Ctrl + O_ и закроем nano используя _Ctrl + X_.
8. Проверим git status
```bash
$ git status
On branch master
nothing to commit, working tree clean
```
Git пишет, что на ветеке мастер нечего коммитит, рабочее дерево пустое. То есть все изменения   
добавленные на коммит-кондидат через git add были закомитчены - теперь копии закомитченных файлов  
храняться в нашем локальном репозитории, а оригиналы, тем временем, лежат на своих местах  
в рабочей папке проекта.  
Теперь git может показать нам историю нашего проекта:  
9. Выполним git log
```bash
$ git log
commit d84afb7b58e4f4be1af2f18f14acdbdb9afd8fc9 (HEAD -> master)
Author: Vladimir Gavruluk <runsakh@gmail.com>
Date:   Fri May 17 09:09:40 2024 +1100

    My first commit

    * Create file test.txt
    * text.txt is tmpty
```
И так, в превой строке у нас hash нашего коммита, а (HEAD -> master) говорит нам, что мы находимся в  
верхушке ветки master - первой ветки нашего прокта с именем поумолчанию.  
10. Внесем изменения в наш файл, добавим его на коммит кондидат.  
```bash
git add .
```
11. Выполним git status
```bash
$ git status
On branch master
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        modified:   test.txt
```
Git нам сообщает, что есть изменения которые должны быть закомитчены и указывает на конкретный  
файл: _**modified:   test.txt**_.



12. Сделаем коммит, но на этот раз попробуем использовать флаг _-m_. Данный флаг означает  
massege и позволяет добавть коротки комментарий который создаст только заголовок но зато  
его можно передать прямо ввиде параметра в команду:  
```bash
$ git commit -m"Make first commit"
[master 03c4b17] Make first commit
 1 file changed, 1 insertion(+)
```
13. Выполним _git status_:
```bash
$ git status
On branch master
nothing to commit, working tree clean
```
И гит нам сообщает, что в ветке мастер нечегокоммитить, рабочее дерево пустое.  
14. Посмотрим историю коммитов выполнив git log но на этот раз отформатируем вывод  
флагом --pretty=forma:"%h - %s | %an - %ad" --date=short  
Сейчас поясню: параметры флага --pretty=format:"" - это аналог функции String.format()  
в которой параметры %h, %s, %an, %ad, а остальное текст нашего шаблона который может быть  
любым.Параметры %h - сокращенный хэш нашего коммита, %s - комментарий нашего коммита,  
%an - name пользователя который сделал коммит, %ad - дата нашего коммита, которая  
по умолчанию выводится в длинном формате. Для того чтобы дата была выведена в котком  
формате добавляем флаг _--date_ с параметром _short_.  
```bash
$ git log --pretty=format"   %h - %s | %an - %ad" --date=short
format   03c4b17 - Make first commit | %UserName% - 2024-05-17
format   d84afb7 - My first commit | %UserName - 2024-05-17
```
Как видим после слова format и трех пробелов идет сокращенный хэш нашего коммита, после тире  
комментарий, затем после вертикальной черты имя пользователя (у меня плейсхолдер), и затем  \
дата в коротком формате. Вот это и есть история наших изменений. Забегая в перед, скажу  
что используя хэш мы сможем например откатывать наши изменения на нужный коммит.  

И так, мы разобрались с самыми основами работы с локальным репозиторием, и теперь пришло  
время научится сохранять наши изменения в удаленном репозитории.


##GitHub##
Для работы с GitHub нам понадобится две вещи
1. Аккаунт на GitHub
2. Сгенерированный SSH-ключ для безопастного соединения с git на нашем компьютере с GtiHub  

Начнем пожалуй с регистрации  

###Создание аккаунта и удаленного репозитория###
1. Идемм на [GitHub](https://github.com "https://github.com"), и создаём аккунт.
2. Войдя в аккаунт, переходим на страницу Repository и жмем кнопку New. В _Repository Name_  
вписываем имя создаваемого удаленного репозитрия, которое, желатьельно, должно совпадать с   
именем локального репозитория который мы будем связывать с нашим создаваемым удаленным.  

###Генерация ssh-ключа###
ssh-ключи лежат обычно в корневой дирректории пользователя __~__ в скрытом каталоге .ssh и если  
мы не создавали ssh-ключи а
```bash
ls -a ~/.ssh/
```
показывает наличие файлов вида:
* id_dsa.pub
* id_ecdsa.pub
* id_ed25519.pub
* id_rsa.pub
то лучще очистить содержимое ~/.ssh/

И так, сгенерируем ключ!
```bash
ssh-keygen -t ed25519 -C"электронная почта к которой привязан акканут GitHub"
```
программа попросит указать дирректорию для храниния ssh-ключей, соглашаемся на предложенный поуомолчанию  
вариант просто нажав Enter. Так же программа попросит ввести кодовую фразу - не будем ничего вводить и  
нажмем Enter. Все, в дирректрии ~/.ssh должны были появится файлы  
* id_ed25519  
* id_ed25519.pub  
id_ed25519 - содержит приватный ssh-ключ который используется для расшифровки сообщений полученных от сервера  
его содержимое не должно никуда передаваться  
di_ed25519.pub - хранит в себе публичный ключ, посредством которого происходит шифрование, его можно передавать  
серверу для установления соединения, далее мы сделаем это.  

###Регистрируем наш SSH-ключ на GitHub###
1. Копируем ключ посредством clip < ~/.ssh/id\_ed25519.pub или копирования текста выведенного через cat ~/.ssh/id\_ed25519.pub 
1. Щелкаем по иконке нашего профиля на GitHub;
2. Выбираем _**Settings**_;
3. В меню расположенном в левой части страницы выбираем пункт _**SSH and GPG keys**_;
4. Жмем кнопку _New SSH key_, где в выбираем опцию Autentication key и вставляем в нужно поле ssh-ключ изх буфера обмена  
, а так же вводим название ключа.
5. Нажимаем кнопку Add SSH key

Наш ключ зарегистрирован на GitHub, нужно это проверить.

6. Для проверки правильности ключа выполняем команду:
```bash
ssh -T git@github.com
```
На что, должно появиться сообщение: 
```bash
Hi %ВАШ_АККАУНТ%! You've successfully authenticated, but GitHub does not provide shell access.
```
###Пирвязываем локальный репозиторий к удаленному на GitHub###
1. Заходим на созданный нами удаленный и на его странице в разделе _Quick setup_ выбираем SSH,  
и копикуем SSH URL (нажав кнопку с квадратиками справа от поля с URL SSH.
2. В GitBash выполняем  
```bash
git remote add origin git@github.com:%ВАШ_АККАУНТ%/gitMinimun.git
```
_git remote add_ принимает два параметра. Первый - имя удаленного репозитория, и его URL SSH.  
3. Проверим связаны ли локальный и удаленный репозитории
```bash
$ git remote -v
origin  git@github.com:"ИМЯ_АККАУНТА"/"ИМЯ_ПРОЕКТА".git (fetch)
origin  git@github.com:"ИМЯ_АККАУНТА"/"ИМЯ_ПРОЕКТА".git (push)
```
4. Переименуем нашу ветку с master на main
```bash
git branch -m main
```
5. Отправим изменения на удаленный репозиторий
```bash
git push -u origin main
```
Флаг -u origin main нужно указывать при первом пуше для связывания одноименной локальной ветки с  
удаленной. При выполнении последующих пушей можно упускать флаг -u.  

 ###git clone###
Чтобы скачать репозиторий с GitHub на свой компьютер можно воспользоваться командой git clone

1. Заходим на интересующий нас репозиторий и 
2. Жмем зеленую кнопку _<Code>_ и на выпадающей панели выбираем SSH, откуда копируем SSH URL, который выгледит  
примерно так: git@github.com:"ИМЯ_АККАУНТА"/"ИМЯ_ПРОЕКТА".git.
3. В GitBash заходим в папку куда хотим поместить удаленный репозиторий выполняем команду  
```bash
git clone git@github.com:"ИМЯ_АККАУНТА"/"ИМЯ_ПРОЕКТА".git.
```
На данном этапе в нашей дирректории должена появится корневая папка клонированного репозитория.  
_git clone_ автоматически связывает удаленный и полученный клонированием локальный репозиторий,  
так что при изменении на удаленном репозитории и можно будет актуализировать локальный репозиторий  
используя команды git.

###fork###
Можно сделать копию интересующего нас репозитория GitHub, на свой репозиторий на GitHub, используя  
fork. Для этого заходим на страницу интересующего нас репозитория и в меню вверху справа находим  
нажимаем кнопку Fork. Далее мы можем поменять имя нашей ветки. Чтобы вносить измениня в данный репозиторий  
выполняем git clone данного репозитория.

И так, я кажется ничего не забыл. Надеюсь это будет полезно для тебя!
